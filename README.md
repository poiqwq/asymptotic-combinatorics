# asymptotic-combinatorics

Поиск центральной меры на градуированном графе

### main.cpp
Граф Юнга с заданным количеством этажей и стоком, для всех вершин с предпоследнего уровня итеративно центрируется и нормируется с помощью алгоритма ромбов до получения центральной меры

Параметры:

int LEVEL -- этаж, до которого будет построен и обработан граф Юнга

int TIMES -- количество итераций приближения (для отладки 1, иначе n > LEVEL)

int VER1 -- индекс первой вершины, ребра, по которому будет выводиться вероятность перехода (индексация вершин с единицы)

int VER2 -- индекс второй вершины ребра

bool ABSTRACT_STOCK -- 1 для стока всех вершин этажа LEVEL в абстрактную вершину на уровне LEVEL + 1, иначе 0

float E -- 0.00001 параметр остановки итерационного приближения (Критерий остановки: среднее квадратическое последней и предпоследней итерации < E)

float START_WEIGT -- начальный вес ребер в графе


Не используется:
int HUNTED -- номер вершины на последнем уровне, в которую будет производиться сток (с дальнейшим переходом к подграфу) 


Алгоритм выводит 2 файла:
1) Вероятность перехода по запрашиваемому ребру в зависимости от итерации
2) СКО в зависимости от итерации

### main_endless.cpp
Граф Юнга с заданным количеством этажей и стоком для всех вершин с предпоследнего уровня итеративно центрируется и нормируется с помощью алгоритма ромбов до получения центральной меры, далее заданное количество раз происходит следующий процесс: удаляется сток и граф Юнга дополняется заданным количеством этажей со стоком, полученный граф итеративно центрируется и нормируется пока не будет получено достаточное приближение к центарльной мере

Параметры:

int LEVEL -- этаж, до которого будет построен и обработан граф Юнга

int FLORES -- количество этажей, которые будут добавляться к изначальному графу на каждом шагу TASK

int LEVEL -- количество итераций добавления этажей к текущему графу Юнга

int TIMES -- количество итераций приближения вероятностной меры к центральной (для отладки -- 1, иначе -- n > LEVEL + FLORES * TASK)

int VER1 -- индекс первой вершины, ребра, по которому будет выводиться вероятность перехода (индексация вершин с единицы)

int VER2 -- индекс второй вершины ребра

bool ABSTRACT_STOCK -- 1 для стока всех вершин этажа LEVEL в абстрактную вершину на уровне LEVEL + 1, иначе 0

float E -- 0.00001 параметр остановки итерационного приближения (Критерий остановки: среднее квадратическое последней и предпоследней итерации < E)

float START_WEIGT -- начальный вес ребер в графе (задать начальную вероятность по Ричардсону -- 0, рандомно на отрезке (0, 1) с точностью до десятых -- 1)


Не используется:
int HUNTED -- номер вершины на последнем уровне, в которую будет производиться сток (с дальнейшим переходом к подграфу) 


Алгоритм выводит 2 файла:
1) Вероятность перехода по запрашиваемому ребру в зависимости от итерации (учитываются итерации из каждого задания TASK)
2) СКО в зависимости от итерации (учитываются итерации из каждого задания TASK)
